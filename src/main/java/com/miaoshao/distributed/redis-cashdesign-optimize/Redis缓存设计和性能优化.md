## 多级缓存架构详解

## 缓存穿透
    1.什么是缓存穿透
        缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不回命中。
        
    2.缓存穿透导致什么问题？
        不存在的数据每次请求都要去数据库查询，失去了缓存保护后端的意义。
        
    3.造成缓存穿透的原因？
        (1)自身业务代码或者数据出现问题
        (2)恶意请求攻击，爬虫等造成大量命中。
    4.解决方案：
        (1)缓存空对象，如果从缓存中没有获取到数据，就从存储获取，如果存储没有命中，也缓存一个空对象。
        (2)布隆过滤器：
           a) 向布隆过滤器添加key,会使用多个hash函数对key进行运算，每个hash函数都会得到一个位置。然后把得到位数组的
              这几个位置都置为1就完成add操作。
           b) 向布隆过滤器询问key是否存在时，把几个位置的hash都算出来，看看是否都为1.只要有一个为0就说明不存在。如果都是1，也不一定
              就存在。只是极有可能存在
              
## 缓存失效
    1.什么是缓存失效
        由于大量缓存在同一时间失效可能导致大量请求同时穿透缓存直达数据库，造成数据库访问压力过大甚至挂掉。
    2.解决方法：
        对于这种情况，在大批量添加缓存的时候，将这一批缓存过期时间设置为一个时间段内不同时间。
        
## 缓存雪崩
    1.什么是缓存雪崩
        缓存雪崩是指缓存层撑不住挂掉，所有请求涌入存储层。
    2.解决方案：
        (1) 保证缓存层的高可用性，使用Redis sentinel哨兵或者Redis cluster集群。
        (2) 使用隔离组件为后端限流熔断并降级。比如使用sentinel或者Hytrix限流降级组件。
        (3) 提前进行Redis缓存的测试演练。模拟场景。如果真的挂掉，采取后续的一些措施。
        
## 热点key重建优化
    开发使用 "缓存+过期时间" 策略可以保证数据读写和定期更新。基本能满足大部分需求。
    但是又两种情况，可能会造成危害：
        1.当前key是个热点key，访问量很大
        2.当缓存重建key短时间不能完成，那么会造成后端压力很大。
    解决方案：
        我们可以使用Redis的互斥锁，来解决这个问题。setnx
        这个方法只允许一个线程重建缓存，其他线程等待重建完成，重新就可以读取到缓存数据了。

## 缓存与数据库双写不一致终极解决
    在大量并发的时候，会存在数据库和缓存数据不一致问题。
    1.双写不一致
        线程1和线程2并发执行
        线程1执行完写数据库后修改值为10，由于其他原因还没有及时更新缓存.
        线程2执行完写数据库后修改值为6，同事及时更新了缓存为6。这时候线程1又执行更新缓存为10.
        这就造成了数据库为6，缓存为10的双写不一致问题。
    2.读写并发不一致
        线程1和线程2和线程3并发执行
        线程1写数据库值为10，同时删除缓存
        线程2开始读取缓存为空，就查询数据为10，然后由于其他原因没有更新缓存
        线程3写数据库值为6，同事删除了缓存。这时候线程2执行到更新缓存，还是更新了10.导致数据库为6，缓存为10.读写不一致。
    3.解决方案：
        对于并发几率很小的数据，几乎不用考虑这个问题。
        如果并发很高，就需要添加读写锁，保证并发读写按顺序排队。读的时候相当无锁。

## Redis开发规范与性能优化
    键值设计：
        key名设计：
            可读简洁，不包换特殊字符
        value设计：
            拒绝bigkey,Redis字符串允许最大512MB。
            但是实际中，如果是String超过10kb就是bigkey.
            如果非字符串，hash,list,set等，元素个数太多就是认为是bigkey。不要超过5000个。
    bigkey危害：
        1. 导致Redis线程阻塞
        2. 过期删除bigkey也会阻塞线程
        
    连接池参数优化：
        maxTotal：最大连接池数
        maxIdle: 最大允许空闲连接数
        minIdle: 最少空间连接数
        最佳性能是 maxTotal = maxIdle